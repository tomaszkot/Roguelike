using Dungeons;
using Dungeons.Core;
using Dungeons.TileContainers;
using Dungeons.Tiles;
using OuaDII.Managers;
using OuaDII.Quests;
using OuaDII.TileContainers;
using OuaDII.Tiles.LivingEntities;
using Roguelike.Core.Managers;
using Roguelike.TileContainers;
using Roguelike.Tiles;
using Roguelike.Tiles.Interactive;
using Roguelike.Tiles.Looting;
using SimpleInjector;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;

namespace OuaDII.Generators
{
  /// <summary>
  /// Class generating levels for a given pit. Unlimited number of levels can be generated by Generate method.
  /// </summary>
  public class LevelGenerator : Roguelike.Generators.LevelGenerator
  {
    string pitName;
    Quests.QuestKind questKind = Quests.QuestKind.Unset;
    int startEnemiesLevel = 1;

    public static Dictionary<Quests.QuestKind, int> PitMaxLevelIndex = new Dictionary<Quests.QuestKind, int>()
    {
      { Quests.QuestKind.CrazyMiller, 1 },
      { Quests.QuestKind.Smiths, 1 },
      { Quests.QuestKind.StonesMine, 1 },
      { Quests.QuestKind.Malbork, 0 },
      { Quests.QuestKind.GatheringEntry, 0 }
    };
    Dictionary<QuestKind, IQuestRoomCreator> questRoomCreators = new Dictionary<QuestKind, IQuestRoomCreator>();

    public LevelGenerator
    (
      Container container, 
      string pitName, 
      int startEnemiesLevel, 
      Dungeons.Core.ILogger logger
    )
      : this(container, pitName, Quests.QuestKind.Unset, startEnemiesLevel, logger)
    {
    }

    public LevelGenerator(Container container, string pitName, Quests.QuestKind questKind, int startEnemiesLevel, Dungeons.Core.ILogger logger) 
      : base(container)
    {
      
      this.startEnemiesLevel = startEnemiesLevel;
      StairsUpOnLevel0 = true;
      this.pitName = pitName;
      this.questKind = questKind;
    }

    public static int GetMaxLevelIndex(QuestKind questKind)
    {
      if (questKind != QuestKind.Unset)
        return PitMaxLevelIndex[questKind];

      return -1;
    }

    public static int GetMaxLevelIndex(string pitName, QuestKind questKind)
    {
      if (questKind != QuestKind.Unset)
        return GetMaxLevelIndex(questKind);

      if(string.IsNullOrEmpty(pitName))
        throw new Exception("string.IsNullOrEmpty(pitName)");
      return Roguelike.Generators.GenerationInfo.DefaultMaxLevelIndex;
    }

    public static int GetMaxLevelIndex(DungeonPit pit)
    {
      return GetMaxLevelIndex(pit.Name, pit.QuestKind);
    }

    public override DungeonLevel Generate(int levelIndex, Dungeons.GenerationInfo info = null, LayouterOptions opt = null)
    {
      var rogeInfo = info as Roguelike.Generators.GenerationInfo;
      if (questKind != QuestKind.Smiths && (rogeInfo == null || rogeInfo.GenerateEnemies))
        extraEnemies.Add("druid");
      if (rogeInfo != null && (questKind == QuestKind.Smiths || questKind == QuestKind.Malbork) )
        rogeInfo.PreventSecretRoomGeneration = true;
      return base.Generate(levelIndex, info, opt);
    }

    int bossNodeIndex = -1;
    bool bossGenerated = false;

    public override int MaxLevelIndex 
    {
      get => GetMaxLevelIndex(pitName, questKind); 
    }
    

    protected override void OnCreate(DungeonNode dungeon, int w, int h, Dungeons.GenerationInfo gi, int nodeIndex)
    {
      var gir = gi as Roguelike.Generators.GenerationInfo;
      if (IsLastLevel)
      {
        if (questKind == QuestKind.Unset && bossNodeIndex == -1)
        {
          bossNodeIndex = RandHelper.GetRandomDouble() < 0.5 ? gi.NumberOfRooms - 1 : gi.NumberOfRooms - 2;
          if (bossNodeIndex == secretRoomIndex)
            bossNodeIndex--;

          if (bossNodeIndex < 0)
            bossNodeIndex = 0;

          //Debug.WriteLine("OnCreate bossNodeIndex = " + bossNodeIndex);
        }

        if (nodeIndex == bossNodeIndex)
        {
          gi.ForceChildIslandInterior = true;
        }
        else
          gi.ForceChildIslandInterior = false;

      }
      base.OnCreate(dungeon, w, h, gi, nodeIndex);
    }

    protected override bool ShallGenerateStairsDown()
    {
      if(string.IsNullOrEmpty(pitName))
        throw new Exception("if(string.IsNullOrEmpty(pitName))");
      return LevelIndex < LevelGenerator.GetMaxLevelIndex(this.pitName, this.questKind);
    }

    public override void ValidateLevelIndex(int levelIndex)
    {
      if (levelIndex > LevelGenerator.GetMaxLevelIndex(this.pitName, this.questKind))
        throw new Exception("levelIndex > LevelGenerator.MaxLevelIndex");
    }

    public GameLevel GenerateLevel(DungeonPit pit, IQuestRoomCreatorOwner owner, int levelIndex)
    {
      if (levelIndex > MaxLevelIndex)
        return null;

      //if (pit.QuestKind == QuestKind.Smiths || pit.QuestKind == QuestKind.Malbork)
      //  RoguelikeGenInfo.MaxLevelIndex = 0;

      if (owner == null)
        owner = DungeonPit.QuestRoomCreatorOwner;

      pit.LevelGenerator = this;

      if (pit.QuestKind != QuestKind.Unset)
      {
        EnsureQuestCreator(pit, owner);
      }

      //var levelIndex = pit.Levels.Count;
      var gi = CreateGenInfo(pit, levelIndex);

      if (pit.QuestKind != QuestKind.Unset)
      {
        if(gi!=null)
          gi.ForcedDungeonLayouterKind = DungeonLayouterKind.Default;
        if (pit.QuestKind == QuestKind.CrazyMiller)
        {
          if (levelIndex == 0)
          {
            gi.ForcedNextRoomSide = Dungeons.EntranceSide.Right;
            gi.ChildIslandAllowed = false;
          }
        }
      }
      var node = Generate(levelIndex, gi);
      var level = node as GameLevel;
      level.Logger = Logger;
      level.GeneratedAt = DateTime.Now;
      return level;
    }

    public IQuestRoomCreator EnsureQuestCreator(DungeonPit pit, IQuestRoomCreatorOwner owner)
    {
      if (!questRoomCreators.ContainsKey(pit.QuestKind))
      {
        Container.GetInstance<ILogger>().LogInfo("GenerateLevel [container] " + Container.GetHashCode());
        var creator = Container.GetInstance<IQuestRoomCreator>();
        creator.Init(owner, pit.QuestKind, this);
        questRoomCreators[pit.QuestKind] = creator;
      }

      return questRoomCreators[pit.QuestKind];
    }

    public void HandleQuestNodeCreated(QuestKind questKind, Dungeons.TileContainers.DungeonNode node)
    {
      var gi = Container.GetInstance<Roguelike.Generators.GenerationInfo>();
      GenerateRoomContent(node, gi, questKind);
    }

    public void SetQuestRoomCreator(IQuestRoomCreatorOwner owner, QuestKind kind, IQuestRoomCreator questRoomCreator)
    {
      questRoomCreators[kind] = questRoomCreator;
      questRoomCreator.Init(owner, kind, this);
    }

    public IQuestRoomCreator GetQuestRoomCreator(QuestKind kind)
    {
      //EnsureQuestCreator(pit, owner);

      if (questRoomCreators.ContainsKey(kind))
        return questRoomCreators[kind];

      return null;
    }

    public Dungeons.GenerationInfo GetGenerationInfo(DungeonPit pit, int levelIndex)
    {
      var info = pit.GetGenInfoAt(levelIndex);
      if (info == null && pit.QuestKind != QuestKind.Unset)
      {
        info = CreateGenInfo(pit, levelIndex);
      }
      return info;
    }
        
    private Roguelike.Generators.GenerationInfo CreateGenInfo(DungeonPit pit, int levelIndex)
    {
      if (pit.GetGenInfoAt(levelIndex) == null)
      {
        if (pit.QuestKind != QuestKind.Unset)
        {
          var maxLevelIndex = GetMaxLevelIndex(pit.QuestKind);
          for (int i = 0; i <= maxLevelIndex; i++)
          {
            var gi = new Roguelike.Generators.GenerationInfo();
            
            gi.NumberOfRooms = 1;

            if (pit.QuestKind == QuestKind.CrazyMiller)
              gi.NumberOfRooms = i == 0 ? 2 : 1;
            //else if (pit.QuestKind == QuestKind.Smiths)

            if (pit.QuestKind != QuestKind.CrazyMiller || i == 0)
              gi.MakeEmpty();

            pit.SetGenInfoAtLevelIndex(i, gi);
          }
        }
      }

      return pit.GetGenInfoAt(levelIndex);
    }

    protected override Stairs CreateStairsUp(int nodeIndex)
    {
      var stairs = base.CreateStairsUp(nodeIndex);
      if (LevelIndex == 0 && stairs.StairsKind == StairsKind.LevelUp)
        stairs.StairsKind = StairsKind.PitUp;
      return stairs;
    }

    protected override DungeonNode CreateNode(int nodeIndex, Dungeons.GenerationInfo gi)
    {
      if (questKind == QuestKind.Smiths || questKind == QuestKind.Malbork)
        gi.PreventSecretRoomGeneration = true;
      var node = base.CreateNode(nodeIndex, gi);
      return node;
    }

    protected override void OnStairsUpCreated(Stairs stairs)
    {
      base.OnStairsUpCreated(stairs);
      stairs.PitName = pitName;
    }

    public override void GenerateRoomContent(int nodeIndex, Dungeons.GenerationInfo gi, Dungeons.TileContainers.DungeonNode node)
    {
      bool isLastLevel = IsLastLevel;
      var rgi = gi as Roguelike.Generators.GenerationInfo;

      if (ShallGenKeys() && KeyPuzzle == KeyPuzzle.Unset)
      {
        if (rgi.ForcedKeyPuzzle != KeyPuzzle.Unset)
          KeyPuzzle = rgi.ForcedKeyPuzzle;
        else
          KeyPuzzle = RandHelper.GetRandomEnumValue<KeyPuzzle>();
        Logger.LogInfo("KeyPuzzle set to " + KeyPuzzle);
      }

      var roomContentGenerator = Container.GetInstance<Roguelike.Generators.RoomContentGenerator>() as RoomContentGenerator;
      

      if (isLastLevel)
      {
        if (node.Parent != null && node.Parent.NodeIndex == bossNodeIndex)
        {
          int k = 0;
          k++;
        }
        if (!bossGenerated && nodeIndex == DungeonNode.ChildIslandNodeIndex && bossNodeIndex == node.Parent.NodeIndex)
        {
          roomContentGenerator.LevelBossName = DungeonPit.GetLastLevelBossNameFromPitName(pitName);
          if (pitName.Contains("_big_"))
            Debug.Assert(false);//remove word big from pit file name!
          var doors = node.Doors.Cast<Roguelike.Tiles.Interactive.Door>().ToList();
          //Debug.WriteLine("GenerateRoomContent generating doors for boss " + roomContentGenerator.LevelBossName);
          

          foreach (var door in doors)
          {
            door.BossBehind = roomContentGenerator.LevelBossName;
            door.KeyName = roomContentGenerator.LevelBossName;
            door.AllInSet = doors;
            door.KeyPuzzle = KeyPuzzle;
          }
          bossGenerated = true;
        }
      }
      //roomContentGenerator.ExtraEnemies = extraEnemies;
      roomContentGenerator.Run(node, LevelIndex, nodeIndex, this.startEnemiesLevel, rgi, this.questKind, pitName);

      if (ShallGenKeys() && node.Secret && KeyPuzzle == KeyPuzzle.SecretRoom)
      {
        var key = CreateKey();
        node.SetTileAtRandomPosition(key);
        Logger.LogInfo("KeyPuzzle.SecretRoom set: " + key);
      }


      var isl = node.ChildIslands.Count;
      if (node.NodeIndex >= 0 && node.NodeIndex == bossNodeIndex)
      {
        if (isl == 0)
          throw new Exception("node.NodeIndex >=0 && node.NodeIndex == bossNodeIndex");
      }
    }
    protected override Key CreateKey()
    {
      var key = base.CreateKey();
      key.KeyName = DungeonPit.GetLastLevelBossNameFromPitName(pitName);
      return key;
    }


    public void GenerateRoomContent(DungeonNode node, Roguelike.Generators.GenerationInfo gi, QuestKind questKind)
    {
      var roomContentGenerator = Container.GetInstance<Roguelike.Generators.RoomContentGenerator>() as RoomContentGenerator;
      roomContentGenerator.Run(node, LevelIndex, node.NodeIndex, this.startEnemiesLevel, gi, this.questKind, pitName);

      
    }

    protected override void OnChildIslandCreated(ChildIslandCreationInfo e)
    {
      base.OnChildIslandCreated(e);
      GenerateRoomContent(e.ChildIslandNode.NodeIndex, e.GenerationInfoIsl, e.ChildIslandNode);
    }
    protected override DungeonLayouterKind CalcLayouterKind()
    {
      if (GenerationInfo.DefaultForcedDungeonLayouterKind != DungeonLayouterKind.Unset)
        return GenerationInfo.DefaultForcedDungeonLayouterKind;
      return base.CalcLayouterKind();
    }


    protected override void CreateDynamicTiles(List<Dungeons.TileContainers.DungeonNode> mazeNodes)
    {
      base.CreateDynamicTiles(mazeNodes);

      Quests.QuestKind questKind = QuestManager.GetQuestKindFromPitName(pitName);
      if (pitName == "pit_down_rats" || pitName == "pit_down_bats")
      {
        var quantity = LootQuestRequirement.QuestLootQuantity(questKind) + LootQuestRequirement.QuestCheatingPunishmentLootQuantity(questKind);

        GenerateQuestLoot(mazeNodes, questKind, quantity);

      }
      if (ShallGenKeys())
      {
        GenerateKeys(mazeNodes);
      }
      //////////!!!!
      if (GenerationInfo.TestLoot)
      {
        var foodKinds = EnumHelper.Values<FoodKind>(true);
        foreach (var fk in foodKinds)
        {
          if (fk != FoodKind.Unset)
          {
            var food = new Food();
            food.SetKind(fk);
            mazeNodes.First().SetTileAtRandomPosition(food);
            if (fk == FoodKind.Meat || fk == FoodKind.Fish)
            {
              var foodR = new Food();
              foodR.SetKind(fk);
              foodR.MakeRoasted();
              mazeNodes.First().SetTileAtRandomPosition(foodR);
            }
          }
        }
        //////////!!!!
      }
    }

    private bool ShallGenKeys()
    {
      bool shall = DungeonPit.GetQuestKind(pitName) == QuestKind.Unset && IsLastLevel;
     
      return shall;
    }

    
    public void GenerateKeys(List<DungeonNode> mazeNodes)
    {
      try
      {
        DungeonNode nodeNonBoss = GetNonBossRoom(mazeNodes);
        
        if (KeyPuzzle == KeyPuzzle.Unset)
        {
          var key = CreateKey();
          nodeNonBoss.SetTileAtRandomPosition(key);
        }
        else if (KeyPuzzle == KeyPuzzle.LeverSet)
        {
          LeverSet = new Roguelike.Core.Managers.LeverSet(Container);
          LeverSet.GenerateLevers();
          var nodeBoss = mazeNodes.Where(i=> IsBossRoom(i)).Single();
          var firstLever = LeverSet.Levers.First();

          nodeBoss.SetTileAtRandomPosition(firstLever);
          foreach (var lever in LeverSet.Levers)
          {
            if (lever == firstLever)
              continue;
            var emp = nodeBoss.GetClosestEmpty(firstLever);
            nodeBoss.SetTile(lever, emp.point);
            firstLever = lever;

            var neibs = nodeBoss.GetNeighborTiles(emp, true);
            neibs.ForEach(i => {
              if (i is Wall wall && !wall.IsSide)
              {
                nodeBoss.SetEmptyTile(i.point);
              }
            });
          }

          LeverSet.StateChanged += (s,e)=>{
            //GetBossDoors(nodeBoss).ForEach(i => i.L = e);
            //if(LeverSet.IsOpened())
            Logger.LogInfo(LeverSet.GetStatus());
          };
          Logger.LogInfo(LeverSet.GetStatus());
        }
        else if (KeyPuzzle == KeyPuzzle.Half)
        {
          var parts = GenerateKeysInLootSources<KeyHalf>(mazeNodes, KeyPuzzle, 2);
          parts[0].SetHandlePart();
        }
        else if (KeyPuzzle == KeyPuzzle.Mold)
        {
          GenerateKeysInLootSources<KeyMold>(mazeNodes, KeyPuzzle, 1);
        }
        else
        {
          GenerateKeysInLootSources<Key>(mazeNodes, KeyPuzzle, 1);
        }
      }
      catch (Exception ex)
      {
        Logger.LogError(ex);
      }
    }

    

    private DungeonNode GetNonBossRoom(List<DungeonNode> mazeNodes)
    {
      //mazeNodes = mazeNodes.Where(i => i.Secret).ToList();
      var node = mazeNodes.GetRandomElem();
      while (IsBossRoom(node))
      {
        node = mazeNodes.GetRandomElem();
      }

      return node;
    }

    List<Door> GetBossDoors(DungeonNode node)
    {
      return node.GetTiles<Door>().Where(i => !string.IsNullOrEmpty(i.BossBehind)).ToList();
    }

    private bool IsBossRoom(DungeonNode node)
    {
      return node.NodeIndex == bossNodeIndex;
    }

    private List<T> GenerateKeysInLootSources<T>(List<DungeonNode> mazeNodes, KeyPuzzle kp, int max) where T : IKey, new()
    {
      var nodeNonBoss = GetNonBossRoom(mazeNodes);
      int counter = 0;
      int tc = 0;
      var res = new List<T>();
      var kps = new[] { KeyPuzzle.Barrel, KeyPuzzle.Chest, KeyPuzzle.Grave, KeyPuzzle.DeadBody };

      while (true)
      {
        if (KeyPuzzle == KeyPuzzle.Mold ||
            KeyPuzzle == KeyPuzzle.Half)
          kp = kps.GetRandomElem();
        tc++;
        //var kp = kps.GetRandomElem();
        ILootSource ls = GetLootSrcForKey(kp, nodeNonBoss);
        if (ls != null && ls.ForcedReward == null)
        {
          

          var key = new T();//key, mold, keypart...
          key.KeyName = DungeonPit.GetLastLevelBossNameFromPitName(pitName);
          ls.ForcedReward = key as Loot;
          res.Add(key);


          Logger.LogInfo("added KeyLootSource "+ ls);
          counter++;
          
        }
        nodeNonBoss = GetNonBossRoom(mazeNodes);
        if (counter == max)
          break;
        if (tc > 1000)
        {
          Logger.LogError("GenKeyLootSources failed! ");
          break;//ups
        }
      }

      return res;
    }

    private ILootSource GetLootSrcForKey(KeyPuzzle keyPuzzle, DungeonNode node)
    {
      ILootSource ls = null;
      if (keyPuzzle == KeyPuzzle.Barrel)
      {
        var barrel = node.GetTiles<Barrel>().Where(i => i.BarrelKind != BarrelKind.OilBarrel).ToList().GetRandomElem();
        if (barrel != null)
          ls = barrel;
      }
      else if (keyPuzzle == KeyPuzzle.Chest || keyPuzzle == KeyPuzzle.Grave)
      {
        var chests = node.GetTiles<Chest>().Where(i => i.ChestKind == ChestKind.Plain);
        var chvk = ChestVisualKind.Chest;
        if (keyPuzzle == KeyPuzzle.Grave)
          chvk = ChestVisualKind.Grave;
        var inter = chests.Where(i=>i.ChestVisualKind == chvk).ToList().GetRandomElem();
        if (inter != null)
          ls = inter;
        else
        {
          if(chests.Any())
            chests.First().ChestVisualKind = chvk;//would be picked next time
        }

      }
      else if (keyPuzzle == KeyPuzzle.DeadBody)
      {
        var inter = node.GetTiles<DeadBody>().GetRandomElem();
        if (inter != null)
          ls = inter;
        else
          ls = node.SetAtPosition(new DeadBody(Container), node.GetRandomEmptyTile(DungeonNode.EmptyCheckContext.DropLoot).point);//would be picked next time
      }
      else if (keyPuzzle == KeyPuzzle.Enemy)
      {
        ls = node.GetTiles<Enemy>().GetRandomElem();
      }
      //node.GenerateAtPosition<DeadBody>(node.GetRandomEmptyTile(DungeonNode.EmptyCheckContext.DropLoot).point);//tmp
      return ls;
    }

    private static void GenerateQuestLoot(List<DungeonNode> mazeNodes, QuestKind questKind, int quantity)
    {
      var perRoom = quantity / mazeNodes.Count;
      var numCreated = 0;
      MinedLootKind minedLootKind = QuestManager.GetMinedLootKind(questKind);
      foreach (var node in mazeNodes)
      {
        var loot = new MinedLoot(minedLootKind);
        node.SetTileAtRandomPosition(loot);
        numCreated++;
      }
      if (numCreated < quantity)
      {
        List<Loot> lootItems = GenerateQuestLoot(quantity - numCreated, questKind);
        foreach (var loot in lootItems)
          mazeNodes[0].SetTileAtRandomPosition(loot);
      }
    }

    public static List<Loot> GenerateQuestLoot(int quantity, QuestKind questKind)
    {
      MinedLootKind minedLootKind = QuestManager.GetMinedLootKind(questKind);
      List<Loot> lootItems = new List<Loot>();
      for (int i = 0; i < quantity; i++)
      {
        lootItems.Add(new MinedLoot(minedLootKind));
      }

      return lootItems;
    }

    protected override List<DungeonNode> CreateDungeonNodes(Dungeons.GenerationInfo info = null)
    {
      var nodes = base.CreateDungeonNodes(info);
      nodes.ForEach(i => {
        if (pitName == WorldGenerator.PitSkeletons)
        {
          i.GetTiles<Chest>().Where(k => k.ChestKind == ChestKind.Plain).ToList().ForEach(c =>
          {
            c.ChestVisualKind = ChestVisualKind.Grave;
            
          });
        }
      });
      return nodes;
    }

    protected override void GenerateStairsDown(DungeonNode maze)
    {
      if (questKind == QuestKind.Smiths || questKind == QuestKind.Malbork)
      {
        return;
      }
      base.GenerateStairsDown(maze);
    }

    protected override Roguelike.Generators.RoomContentGenerator CreateRoomContentGeneratorForExtraEnemies()
    {
      var roomGen = base.CreateRoomContentGeneratorForExtraEnemies();
      roomGen.EnemiesStartLevel = startEnemiesLevel;
      return roomGen;
      
    }

    protected override bool CanGenerateOilSpread()
    {
      if (questKind == QuestKind.Smiths || questKind == QuestKind.Malbork || questKind == QuestKind.StonesMine ||
          questKind == QuestKind.CrazyMiller)
        return false;
      return true;
    }

    //KeyPuzzle GenerateKeyPuzzle(DungeonPit pit)
    //{
    //  return KeyPuzzle.Barrel;
    //}

    protected override void InitGenerationInfo(Dungeons.GenerationInfo info)
    {
      var rogeInfo = info as Roguelike.Generators.GenerationInfo;
      rogeInfo.KeyPuzzle = this.KeyPuzzle;
    }

  }
}
